# 구조 및 알고리즘 개요 (Structure)

## 개요

이 문서는 Reverse Overflow 기반 Multiple Stack 자료구조의 핵심 개념과 내부 구조를 설명합니다.  
이 자료구조는 하나의 고정 배열에서 여러 개의 스택이 **공간을 공유**하며 구현되는 방식으로,  
기존의 **균등 분할 방식**에서 발생하는 메모리 낭비 문제를 해결하기 위한 대안으로 제안되었습니다.

---

## 핵심 아이디어

- 각 스택은 배열 내 특정 위치에서 시작하여 **자신의 방향**으로 성장합니다.
- 기본적으로는 침범 없이 자라되, 공간이 부족해지면 **Reverse Overflow** 로직을 통해  
  인접 스택의 **유휴 공간을 역방향으로 탐색하여** 사용할 수 있습니다.
- pop 시에는 침범된 공간을 회수하고, **원래 구조를 최대한 보존**하도록 설계됩니다.

---

## 배열 내 스택 배치 예시

4개의 스택(S0, S1, S2, S3)이 **하나의 배열**에서 서로 반대 방향으로 자라며  
공간을 공유하는 예시는 다음과 같습니다.

### 배열 인덱스

[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ]

### 스택 배치 및 성장 방향

<pre> ``` |→ S0 →|← S1 ←| |→ S2 →|← S3 ←| [ 0 ... 7 ][ 8 ... 15 ] ``` </pre>


---

## 스택별 설명

- **S0**: 배열의 왼쪽에서 오른쪽(→)으로 성장 *(정방향)*  
- **S1**: S0 인접에서 오른쪽에서 왼쪽(←)으로 성장 *(역방향)*  
- **S2**: 배열의 오른쪽 영역에서 왼쪽에서 오른쪽(→)으로 성장 *(정방향)*  
- **S3**: 배열의 끝에서 왼쪽(←)으로 성장 *(역방향)*  

각 스택은 인접 스택의 공간을 **Reverse Overflow** 방식으로 침범 가능하며,  
배열 내 고정된 크기 안에서 **동적으로 공간을 공유**합니다.

---

## 공간 공유 전략

총 배열 용량이 16칸이라고 해도,  
각 스택을 4칸씩 **고정 할당하지 않습니다.**  
대신 **실시간 사용량에 따라 유동적으로 공간을 배분**합니다.

예시:  
- S0이 6칸을 사용하고, S1이 1칸만 사용한다면  
  → S0은 S1의 미사용 공간을 침범하여 사용할 수 있습니다.

---

## 장점 요약

- **메모리 활용 최적화**: 필요에 따라 동적 확장  
- **Reverse Overflow**로 유휴 공간 재활용  
- **정적 배열에서도 유연한 스택 구현 가능**  
- **pop 시 구조 안정성 유지**

---

다음 문서인 [`implementation.md`](./implementation.md)에서는 이 구조의 실제 구현 방식과  
알고리즘에 대해 상세히 설명합니다.
