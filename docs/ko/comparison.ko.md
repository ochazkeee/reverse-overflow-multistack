# Multiple Stack 구조 비교 (Comparison of Multiple Stack Structures)

## 개요

이 문서는 다양한 Multiple Stack 구현 방식들과  
Reverse Overflow 기반 구조를 비교하여,  
공간 효율성, 시간 복잡도, 유연성 등 주요 지표에서  
각 구조의 장단점을 정리합니다.

본 비교는 배열 기반 또는 고전적인 다중 스택 구현 방식에 집중하였으며,  
특수한 상황에 최적화된 구조는 제외하였습니다.

---

## 비교 대상 구조

1. **고정 파티셔닝 (Fixed Partitioning)**
2. **동적 리사이징 (Dynamic Resizing)**
3. **링크드 리스트 기반 스택 (Linked Stack - Knuth 방식)**
4. **Reverse Overflow 기반 구조 (제안 방식)**

---

## 1. 고정 파티셔닝 (Fixed Partitioning)

| 항목 | 내용 |
|------|------|
| **구조** | 하나의 배열을 고정된 크기로 n등분하여 각 스택에 할당 |
| **장점** | 구현이 매우 간단하며, 각 스택 간 간섭이 없음 |
| **단점** | 공간 낭비가 심각할 수 있음 (한 스택만 가득 차도 나머지 공간 미사용) |
| **시간 복잡도** | O(1) (push/pop) |
| **유연성** | 매우 낮음 |

---

## 2. 동적 리사이징 (Dynamic Resizing)

| 항목 | 내용 |
|------|------|
| **구조** | 각 스택이 자신의 공간을 다 쓰면 전체 배열을 재구성하여 크기를 조절 |
| **장점** | 공간을 재분배하여 효율적으로 사용할 수 있음 |
| **단점** | 리사이징 시 복사 및 재정렬 등의 연산이 발생하여 성능 저하 가능 |
| **시간 복잡도** | 평균 O(1), 최악 O(n) (리사이징 시 전체 복사) |
| **유연성** | 보통 |

---

## 3. 링크드 스택 (Linked Stack / Knuth 방식)

| 항목 | 내용 |
|------|------|
| **구조** | 배열 기반이 아닌 노드 연결 방식으로 각 노드가 다음 노드를 가리킴 |
| **장점** | 공간을 동적으로 활용 가능, 구조 확장성 높음 |
| **단점** | 포인터 오버헤드 발생, 대규모 시스템에서 캐시 미스 가능성 ↑, 구현 복잡 |
| **시간 복잡도** | O(1) (추가/제거) |
| **공간 오버헤드** | 높음 (노드당 포인터 필요) |
| **유연성** | 높음 |

※ 링크드 스택은 메모리 지역성이 낮아 **대규모 배열 환경에서 캐시 미스**가 두드러질 수 있습니다.

---

## 4. Reverse Overflow 기반 구조 (제안 방식)

| 항목 | 내용 |
|------|------|
| **구조** | 하나의 고정 배열을 여러 스택이 공유하며, 각 스택은 자신의 기본 영역을 초과할 경우 인접 스택의 공간을 역방향으로 침범 |
| **장점** | 공간 효율성이 매우 높고, 배열 하나로 다수 스택의 동적 공간 공유 가능. 캐시 친화적이며 고정 배열 내에서 리사이징 없이 운영 가능 |
| **단점** | overflow 시 인접 스택 탐색 및 owner 추적 로직 필요, 구현 난이도 ↑ |
| **시간 복잡도** | 평균 O(1), 최악 O(k) (k는 스택 수, 역방향 탐색 시) |
| **유연성** | 매우 높음 |
| **오버헤드** | owner 정보 추적 필요 (별도 메타배열 또는 색인 맵 등으로 구현 가능) |

---

## 종합 비교 표

| 항목 | 고정 파티셔닝 | 동적 리사이징 | 링크드 스택 | Reverse Overflow |
|------|----------------|----------------|--------------|------------------|
| **구현 난이도** | 매우 쉬움 | 보통 | 어려움 | 보통~어려움 |
| **공간 효율성** | 매우 낮음 | 보통 | 높음 | 매우 높음 |
| **시간 복잡도** | O(1) | 평균 O(1), 최악 O(n) | O(1) | 평균 O(1), 최악 O(k) |
| **유연성** | 낮음 | 보통 | 높음 | 매우 높음 |
| **캐시 최적화** | 좋음 | 좋음 | 낮음 (캐시 미스 가능성 ↑) | 좋음 |
| **오버헤드** | 없음 | 리사이징 비용 | 포인터 비용 | owner 추적 비용 |

---

## 결론

Reverse Overflow 기반 구조는  
- **캐시 친화성**,  
- **공간 효율**,  
- **유연성**에서 매우 강력한 특성을 보이며,  
리사이징 없이 다수의 스택을 **하나의 배열 안에서 효율적으로 운영**할 수 있습니다.

링크드 리스트처럼 포인터를 사용하지 않고,  
동적 리사이징처럼 전체 배열을 재조정하지 않으면서도  
**스택 간 동적 공간 공유**를 구현할 수 있다는 점에서  
**실용성과 성능을 모두 만족시키는 혁신적 구조**라 할 수 있습니다.

특히, owner 정보는 메타 배열 또는 색인 방식으로 효율적으로 관리 가능하며,  
캐시 친화적 배열 기반 구현이라는 점에서 실전 응용에 유리합니다.

