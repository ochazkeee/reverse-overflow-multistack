# 자주 묻는 질문 (FAQ)

## 이 구조는 어디에 쓰이는 건가요?

Reverse Overflow 기반의 Multiple Stack 구조는 고정된 배열 안에서 여러 개의 스택을 효율적으로 구현해야 할 때 유용합니다.  
예를 들어, 임베디드 시스템처럼 메모리가 제한적인 환경에서 메모리 낭비 없이 스택을 운용해야 하는 경우에 적합합니다.

---

## 기존의 균등 분할 방식과 무엇이 다른가요?

기존 방식은 전체 배열을 고정 크기로 균등하게 나눈 뒤, 각 스택에 고정된 공간을 할당합니다.  
하지만 일부 스택이 빠르게 가득 차는 경우, 남은 스택의 미사용 공간이 낭비될 수 있습니다.

Reverse Overflow 방식은 각 스택이 자신의 방향으로 자라다가 공간이 부족하면, 인접한 스택의 남은 공간을 역방향으로 탐색하여 사용하는 전략입니다.  
이를 통해 공간 활용률을 비약적으로 개선할 수 있습니다.

---

## Q: Reverse Overflow 방식과 Flexible Equal Partitioning 방식의 차이점은 무엇인가요?

**A:** 두 방식 모두 다중 스택에서 동적으로 메모리를 재분배하여 효율성을 높이는 것을 목표로 하지만, 다음과 같은 주요 차이점이 있습니다:

- **확장 방향 (Expansion Direction):**  
  - **Flexible Equal Partitioning** 방식은 보통 전체 배열을 균등하게 나눈 후, 한 스택이 가득 찼을 때 인접한 영역으로 전진하는(즉, 정방향) 방식으로 확장이 이루어집니다.  
  - **Reverse Overflow** 방식은 기본 영역이 부족해질 경우, 스택이 인접한 스택의 미사용 공간을 **역방향(즉, 반대 방향)**으로 탐색하여 침범함으로써 추가 영역을 확보합니다.

- **회수 로직 (Reclaim Mechanism):**  
  - Flexible Equal Partitioning에서는 스택 간의 영역 재분할이 필요할 경우 전체 영역의 재조정이 발생할 수 있고, 이로 인해 구현과 성능 측면에서 오버헤드가 발생할 수 있습니다.  
  - Reverse Overflow 방식은 `pop` 연산 시 침범한 공간을 자동으로 회수하여, 원래의 구조를 최대한 보존하면서 필요한 경우에만 공간 침범이 발생합니다.

- **구현 전략 (Implementation Strategy):**  
  - Flexible Equal Partitioning은 전체 배열의 영역을 균등하게 분할하여 관리하므로, 한 스택이 빨리 가득 차면 다른 스택의 남은 영역이 사용되지 않아 메모리 낭비가 발생할 수 있습니다.  
  - Reverse Overflow 방식은 각 스택이 자신의 영역을 기본적으로 유지하면서도, 필요에 따라 인접 스택의 유휴 공간을 선택적으로 활용할 수 있도록 설계되어, 더욱 유연하고 효율적인 공간 활용을 제공합니다.

따라서, Reverse Overflow 방식은 단순히 영역을 재분배하는 것에 그치지 않고, 침범 및 회수 로직을 통해 전체 배열의 메모리 활용도를 극대화하는 점에서 차별화됩니다.

---

## 실제 성능은 어떤가요?

`benchmarks/` 디렉토리에는 다양한 구현과 비교 실험을 위한 스크립트가 포함되어 있습니다.  
초기 테스트 결과, Reverse Overflow 구조는 균등 분할 방식 대비 공간 효율에서 큰 장점을 보였습니다.

시간 복잡도 측면에서는 약간의 오버헤드가 존재할 수 있으나, 회수 로직과 탐색 최적화를 통해 충분히 성능을 확보할 수 있습니다.  
자세한 비교 결과는 `docs/comparison.md`를 참조해 주세요.

---

## 다른 스택을 침범해도 안전한가요?

침범 로직은 다음 조건을 기반으로 동작합니다:

- 인접 스택의 미사용 공간만을 탐색합니다.
- 사용 중인 영역을 건드리지 않도록 보호 장치가 마련되어 있습니다.
- pop 시에는 회수 로직이 동작하여 침범한 공간을 반환합니다.

하지만 이 구현은 아직 실험적인 단계이므로, 다양한 테스트를 통해 안정성과 경계 조건을 검증하는 중입니다.

---

## 이 구조는 확장 가능한가요?

예. 이 구조는 스택 수를 동적으로 설정할 수 있도록 설계되었습니다.  
배열 크기를 바꾸지 않더라도, 스택의 수를 조정하거나 다른 방향성을 부여하는 등의 응용도 가능합니다.

---

## 이 구조에 대한 기여는 어떻게 하나요?

이 프로젝트는 MIT 라이선스 하에 공개되어 있으며, 누구나 자유롭게 사용, 수정, 배포하실 수 있습니다.  
아이디어나 구현 방식에 대해 제안이 있으신 경우,  
[이슈를 등록하거나](https://github.com/ochazkeee/reverse-overflow-multistack/issues) 직접 PR(Pull Request)을 보내주시면 감사하겠습니다.

구조 개선, 코드 리팩토링, 테스트 케이스 작성, 문서화 등 어떤 형태의 기여도 환영입니다.

---

## 이 구조는 독창적인가요?

Reverse Overflow 방식은 기존 자료구조 교과서나 일반적인 구현에서는 거의 등장하지 않는 방식입니다.  
현재까지 확인된 바로는, 배열 내 다중 스택 구현에서 이러한 **역방향 공간 침범 + 회수 로직을 조합한 구조**는 흔치 않습니다.  
하지만 혹시 유사한 방식이 있었다면, 언제든 제보해 주시면 감사하겠습니다.

이 프로젝트는 학습과 실험의 일부로, 아이디어 공유 및 토론을 장려하기 위해 공개되었습니다.
